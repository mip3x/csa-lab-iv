# csa-lab-iv

4-ая лабораторная работа в рамках дисциплины "Архитектура компьютерных систем"

Вариант: `forth | cisc | harv | hw | tick | binary | trap | port | pstr | prob1 | vector`

Расшифровка варианта:
 - `forth` - синтаксис языка `Forth` с обратной польской нотацией
 - `cisc` - система команд должна содержать сложные инструкции
 - `harv` - для организации памяти используется гарвардская архитектура
 - `hw` - устройство управления реализуется как часть модели
 - `tick` - процессор необходимо моделировать с точностью до такта
 - `binary` - бинарное представление машинного кода
 - `trap` - ввод-вывод осуществляется токенами через систему прерываний
 - `port` - port-mapped ввод и вывод
 - `pstr` - строки должны быть в `Pascal` формате

## Оглавление

- [Язык программирования](#Язык-программирования)
    - [Синтаксис](#Синтаксис)
    - [Семантика](#Семантика)
- [Организация памяти](#Организация-памяти)
    - [Регистры](#Регистры)
- [Система команд](#Система-команд)
    - [Особенности процессора](#Особенности-процессора)
    - [Виды адресации](#Виды-адресации)
    - [Набор инструкций](#Набор-инструкций)
    - [Способ кодирования инструкций](#Способ-кодирования-инструкций)
- [Транслятор](#Транслятор)
- [Модель процессора](#Модель-процессора)
    - [DataPath](#DataPath)
    - [ControlUnit](#ControlUnit)
- [Тестирование](#Тестирование)

## Язык программирования

### Синтаксис

Форма Бэкуса-Науэра:

```ebnf
<program> ::= <bindings> <body>

<bindings> ::= <binding>*

<binding> ::= <definition> | <declaration>

<definition> ::= ":" <ident> <body> ";"

<body> ::= <statement>*

<statement> ::= <number>
            | <string>
            | <ident>
            | <if_stmt>
            | <loop_stmt>
            | <trap_block>
            | <require>

<declaration> ::= "var" <ident> (<number>)?
            | "str" <ident> <string>
            | <number> "const" <ident>
            | <number> "alloc" <ident>
            | "vector" <number> ":" <ident>

<if_stmt> ::= "if" <body> ("else" <body>)? "then"

<loop_stmt> ::= "begin" <body> "until"
            | <number> "times" <body> "next"

<trap_block> ::= "trap" <ident> <body> "endtrap"

<require> ::= "#require" <string>

<number> ::= <decimal> | <hexadecimal>

<decimal> ::= <digit>+                           

<hexadecimal> ::= "0x" <hex_digit>+                  

<ident> ::= <letter> (<letter> | <digit> | "_")*

<string> ::= [^"]

<letter> ::= [a-zA-Z]
<digit> ::= [0-9]
<hex_digit> ::= <digit> | [a-fA-F]
```

### Семантика

- Подробное описание команд находится в [этом файле](./docs/prog-lang.md) документации
- Все данные имеют глобальную область видимости
- Стратегия вычислений: стековая
- Типизация: бестиповая (отсутствует)
- Нотация: обратная польская (постфиксная). Оператор идёт после операндов

#### Особенности реализации

- Каждое слово разделено пробелом

## Организация памяти

- Модель памяти соответствует **гарвардской архитектуре**: есть разделение на **память команд** и **память данных**
- Память данных:
    - Хранит строковые литералы, константы, переменные и последовательные блоки данных
    - Строковые литералы упакованы неплотно, хранятся в памяти в формате `pascal`-строки

    > Неплотная упаковка косвенно обусловлена отсутствием типизации в `Forth`: все значения хранятся в ячейках фиксированного размера. Возможно несколько решений. Приведу некоторые:
    >
    > - реализация команд побайтового доступа для строковых литералов и блоков последовательной памяти (пример: `c@`, `c!`)
    > - реализация неявных типов в трансляторе
    >
    > Так или иначе, эти решения усложнили бы архитектуру. Было принято решение этого не делать

    - Блоки данных хранятся в памяти в виде непрерывной последовательности ячеек. Обращение отображается в загрузку значения адреса начала выделенного блока на стек данных
    - Переменные отображаются в загрузку значения адреса переменной на стек данных
    - Константы отображаются в загрузку значения константы на стек данных
    - Константы/переменные двойной точности хранятся в двух ячейках. При размещении в памяти младшее слово размещается раньше старшего
    - Размер машинного слова - **32 бита**
    - Доступна программисту: он может влиять на стек данных и стек адресов возврата. Также возможно неявное влияние на стек адресов возврата вызовом процедур и возвратом из них
    - Поддерживыемые типы адресации:
        - **Абсолютная**: прямая загрузка литерала в ячейку памяти
        - **Косвенная**: достижима с использованием стека
    - Динамического выделения памяти нет
    - Стек данных растёт вниз (в сторону уменьшения адресов), стек адресов возврата растёт вверх (в сторону увеличения адресов)

    > Такое устройство может помочь избежать проблемы, при которой значения стека адресов возврата начнут перекрывать значения стека данных

- Память команд:
    - Хранит инструкции для выполнения, векторы прерываний, тела обработчиков, процедуры
    - Размер машинного слова - **32 бита**
    - Поддерживыемые типы адресации:
        - **Абсолютная**
    - Не доступна программисту
- Для обоих типов памяти характерно **линейное адресное пространство**
- Данные в памяти хранятся в формате `Big-endian`

```text
       Instruction memory
+------------------------------+
| 00  : jmp n                  |
|    ...                       |
| 10  : interruption vector 1  |
| 11  : interruption vector 2  |
|    ...                       |
| n   : program start          |
|    ...                       |
| i   : interruption handler 0 |
| i+1 : interruption handler 1 |
|    ...                       |
| f   : function 1 body        |
|    ...                       |
| g   : function 2 body        |
|    ...                       |
+------------------------------+

          Data memory
+------------------------------+
| 00  : constant 1             |
| 01  : constant 2             |
|    ...                       |
| s+0 : string literal 1 len   |
| s+1 : string literal 1 [0]   |
|    ...                       |
| v+0 : variable 1             |
| v+1 : variable 2             |
| v+2 : variable 3             |
|    ...                       |
| b   : buffer1[0]             |
| b+1 : buffer1[1]             |
|    ...                       |
| d   : data stack             |
| r   : return stack           |
|    ...                       |
+------------------------------+
```
### Регистры

Общее количество регистров - **16**. Регистры являются **32-битными**. Программист не может явно взаимодействовать ни с одним из регистров

Специальные регистры:
- `PC` (`Program Counter`): хранит адрес ячейки памяти команд, содержащей следующую исполняемую команду программы. Автоматически инкрементируется на каждом такте. Может быть изменён инструкциями перехода
- `AR` (`Address Register`): хранит адрес ячейки памяти данных
- `DR` (`Data Register`): хранит данные для операций загрузки/выгрузки данных
- `SP` (`Data Stack Pointer`): указывает на вершину стека данных
- `RP` (`Return Stack Pointer`): указывает на вершину стека адресов возврата
- `IR` (`Instruction Register`): хранит исполняемую команду
- `SPC` (`Shadow Program Counter`): используется для сохранения `PC` в случае обработки прерывания

Регистры общего назначения:
- `EAX`, `EBX`, `ECX`, `EDX`, `EFX`, `r6`, `r7`, `r8`, `r9`, `r10`: универсальные регистры

## Система команд

### Особенности процессора

- Имеется возможность разрешать и запрещать прерывания
- По умолчанию прерывания запрещены

### Виды адресации

- Регистровая (`register-to-register`): работа напрямую с регистрами

    Пример:

    ```asm
    mov EAX, EBX    ; скопировать значение из регистра EBX в регистр EAX
    ```

- Непосредственная (`immediate`): работа с непосредственно-загружаемым 32-битным значением

    Пример:

    ```asm
    mov ECX, 42     ; поместить в регистр ECX значение 42
    ```

- Косвенная (`indirect`): работа со значением, взятым из памяти данных по адресу из регистра

    Пример:

    ```asm
    mov EAX, [EDX]  ; поместить в регистр EAX значение, которое находится в памяти данных по адресу, зафиксированному в регистре EDX
    ```

- Индексная (`indirect+immediate_offset`): работа со значением, взятым из памяти данных по адресу, который является суммой непосредственного загружаемого значения и значения (адреса) из регистра

    Пример:

    ```asm
    mov EAX, [EFX + 4] ; поместить в регистр EAX значение, которое находится в памяти данных по адресу, значение которого равно сумме зафиксированного в регистре EFX + 4
    ```

### Набор инструкций

Подробное описание набора инструкций и кодов операций находится в [этом файле](./docs/isa.md) документации

### Способ кодирования инструкций

Инструкций - 31, регистров - больше 8, меньше 16. Следовательно, опкод можно закодировать минимально в 5 битах, регистр - в 4 битах

> Под поле `опкод` заложено 6 бит ради возможности расширения набора инструкций

Описание:
- `opcode` - код операции (опкод)
- `addr_t` - типы адресации для каждого из операндов (2 бита на каждый из 3 операндов = 6 бит); кодируются следующим образом:
    - `Регистровая`: `00`
    - `Непосредственная`: `01`
    - `Косвенная`: `10`
    - `Индексная`: `11`
- `rd` - регистр назначения
- `rs1` - регистр-источник #1
- `rs2` - регистр-источник #2

Для операций с типом адресации `Непосредственная` и `Индексная` непосредственное (`immediate`) значение следует вторым машинным словом

Для операций ввода-вывода номер порта кодируется 10-битным значением (таким образом, доступно 1024 портов ввода-вывода)

```
┌───────────┬──────────┬───────────┬──────────┬───────────┬──────────┐
│  31..24   │  23..20  │  19..16   │  15..12  │   11..6   │   5..0   │              
├───────────┼──────────┼───────────┼──────────┼───────────┼──────────┤
│    0x0    │    rs2   │    rs1    │    rd    │   addr_t  │  opcode  │         
└───────────┴──────────┴───────────┴──────────┴───────────┴──────────┘
```

## Транслятор

## Модель процессора

### DataPath

![DataPath](img/DataPath.svg)

#### Сигналы:

- `latch_ar` - защёлкнуть значение в регистре `AR`
- `dm_read` - прочитать значение из памяти данных по адресу `dm_addr`, значение будет выведено на `data_memory_out`
- `dm_store` - записать значение в память данных по адресу `dm_addr`, будет записано значение с `alu_out`
- `sel_alu_oper` - выбрать операцию АЛУ
- `perform_alu_oper` - выполнить операцию АЛУ и установить флаги
- `lach_dst` - защёлкнуть значение `dst` в регистре `rd`
- `sel_ar` (`sel AR`) - выбрать значение `AR` на мультиплексоре:
    - сумма `imm` и значения `rd`
    - значение `rd`
    - значение `rs1`
    - сумма `imm` и значения `rs1`
- `sel_alu_left_oper` - выбрать левый операнд АЛУ:
    - `rs1`
    - `0`
    - `imm`
- `sel_alu_right_oper` - выбрать правый операнд АЛУ:
    - `rs2`
    - `4`
    - `imm`
- `sel_write_src` - выбрать источник для записи в регистр `rd` ИЛИ на шину данных ВУ `io_data`:
    - `alu_out` - выход АЛУ
    - `data_memory_out` - выход памяти данных

#### Флаги

Устанавливаются по результату каждой из операций АЛУ

- `negative` (`N`) - результат отрицательный
- `zero` (`Z`) - результат операции равен нулю
- `overflow` (`V`) - в результате выполнения операции возникло переполнение
- `carry` (`C`) - бит переноса, устанавливается при переполнении в арифметических операциях

### ControlUnit

![ControlUnit](img/ControlUnit.svg)

#### Сигналы

- `latch_pc` - защёлкнуть значение счётчика команд (регистр `PC`)
- `sel_pc` - выбрать источник для записи в регистр `PC`:
    - `next_pc_seq` - счётчик команд (`PC`), увеличенный на единицу
    - `next_pc_shadow` - восстановить счётчик команд, который был до прерывания (`SPC`)
    - `next_pc_imm_addr` - перейти по абсолютному адресу (для `jmp`)
    - `next_pc_int_vector` - перейти на инструкцию вектора прерывания
- `latch_spc` - защёлкнуть значение `SPC` (`shadow PC`)
- `im_read` - прочитать значение из памяти инструкций по адресу из `PC`
- `latch_ir` - защёлкнуть значение `IR`
- `en_int`/`dis_int` - записать в регистр `EI` (разрешение прерываний) 1/0
- `latch_port` - защёлкнуть значение `PORT`
- `sel_dp_write` - выбрать источник для `imm`:
    - `imm` - передать непосредственное (`immediate`) значение
    - `io_dev_data` - передать значение с шины данных ВУ
- `intrq` - запрос прерывания от неизвестного ВУ
- `intack` - подтверждение прерывания, ожидание порта от КВУ на шину `dev_port`

#### Ввод-вывод

***Примечания***: `ВУ` - `Внешнее устройство`, `КВУ` - `Контроллер внешних устройств`

Устройство генерирует сигнал `intrq` (`Interrupt request`), КВУ передаёт его. После этого CU отправляет `intack`, и ВУ, которое требовало прерывание, должно передать порт, к которому оно подключено. Порт сравнивается с портом из инструкции, и, если они совпадают, то происходит переход на адрес обработчика прерывания: порт умножается на 2 (сдвиг влево на 1), после чего складывается с `vector_base` (регистром, хранящим адрес начала векторов прерываний), выход идёт по шине `next_pc_int_vector` и должен быть выбран на мультиплексоре. Вектора обработчиков прерываний - набор безусловных переходов (`jmp`) на адреса обработчиков прерываний. 

## Тестирование
