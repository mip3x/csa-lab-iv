# csa-lab-iv

4-ая лабораторная работа в рамках дисциплины "Архитектура компьютерных систем"

Вариант: `forth | cisc | harv | hw | tick | binary | trap | port | pstr | prob1 | vector`

Расшифровка варианта:
 - `forth` - синтаксис языка `Forth` с обратной польской нотацией
 - `cisc` - система команд должна содержать сложные инструкции
 - `harv` - для организации памяти используется гарвардская архитектура
 - `hw` - устройство управления реализуется как часть модели
 - `tick` - процессор необходимо моделировать с точностью до такта
 - `binary` - бинарное представление машинного кода
 - `trap` - ввод-вывод осуществляется токенами через систему прерываний
 - `port` - port-mapped ввод и вывод
 - `pstr` - строки должны быть в `Pascal` формате

## Оглавление

- [Язык программирования](#Язык-программирования)
    - [Синтаксис](#Синтаксис)
    - [Семантика](#Семантика)
- [Организация памяти](#Организация-памяти)
    - [Регистры](#Регистры)
- [Система команд](#Система-команд)
    - [Особенности процессора](#Особенности-процессора)
    - [Виды адресации](#Виды-адресации)
    - [Набор инструкций](#Набор-инструкций)
    - [Способ кодирования инструкций](#Способ-кодирования-инструкций)
- [Транслятор](#Транслятор)
- [Модель процессора](#Модель-процессора)
    - [DataPath](#DataPath)
    - [ControlUnit](#ControlUnit)
- [Тестирование](#Тестирование)

## Язык программирования

### Синтаксис

Форма Бэкуса-Науэра:

```ebnf
<program> ::= <bindings> <body>

<bindings> ::= <binding>*

<binding> ::= <definition> | <declaration>

<definition> ::= ":" <ident> <body> ";"

<body> ::= <statement>*

<statement> ::= <number>
            | <string>
            | <ident>
            | <if_stmt>
            | <loop_stmt>
            | <trap_block>
            | <require>

<declaration> ::= "var" <ident> (<number>)?
            | "str" <ident> <string>
            | <number> "const" <ident>
            | <number> "alloc" <ident>
            | "vector" <number> ":" <ident>

<if_stmt> ::= "if" <body> ("else" <body>)? "then"

<loop_stmt> ::= "begin" <body> "until"
            | <number> "times" <body> "next"

<trap_block> ::= "trap" <ident> <body> "endtrap"

<require> ::= "#require" <string>

<number> ::= <decimal> | <hexadecimal>

<decimal> ::= <digit>+                           

<hexadecimal> ::= "0x" <hex_digit>+                  

<ident> ::= <letter> (<letter> | <digit> | "_")*

<string> ::= [^"]

<letter> ::= [a-zA-Z]
<digit> ::= [0-9]
<hex_digit> ::= <digit> | [a-fA-F]
```

### Семантика

- Подробное описание команд находится в [этом файле](./docs/prog-lang.md) документации
- Все данные имеют глобальную область видимости
- Стратегия вычислений: стековая
- Типизация: бестиповая (отсутствует)
- Нотация: обратная польская (постфиксная). Оператор идёт после операндов

#### Особенности реализации

- Каждое слово разделено пробелом

## Организация памяти

- Модель памяти соответствует **гарвардской архитектуре**: есть разделение на **память команд** и **память данных**
- Память данных:
    - Хранит строковые литералы, константы, переменные и последовательные блоки данных
    - Строковые литералы упакованы неплотно, хранятся в памяти в формате `pascal`-строки

    > Неплотная упаковка косвенно обусловлена отсутствием типизации в `Forth`: все значения хранятся в ячейках фиксированного размера. Возможно несколько решений. Приведу некоторые:
    >
    > - реализация команд побайтового доступа для строковых литералов и блоков последовательной памяти (пример: `c@`, `c!`)
    > - реализация неявных типов в трансляторе
    >
    > Так или иначе, эти решения усложнили бы архитектуру. Было принято решение этого не делать

    - Блоки данных хранятся в памяти в виде непрерывной последовательности ячеек. Обращение отображается в загрузку значения адреса начала выделенного блока на стек данных
    - Переменные отображаются в загрузку значения адреса переменной на стек данных
    - Константы отображаются в загрузку значения константы на стек данных
    - Константы/переменные двойной точности хранятся в двух ячейках. При размещении в памяти младшее слово размещается раньше старшего
    - Размер машинного слова - **32 бита**
    - Доступна программисту: он может влиять на стек данных и стек адресов возврата. Также возможно неявное влияние на стек адресов возврата вызовом процедур и возвратом из них
    - Поддерживыемые типы адресации:
        - **Абсолютная**: прямая загрузка литерала в ячейку памяти
        - **Косвенная**: достижима с использованием стека
    - Динамического выделения памяти нет
    - Стек данных растёт вниз (в сторону уменьшения адресов), стек адресов возврата растёт вверх (в сторону увеличения адресов)

    > Такое устройство может помочь избежать проблемы, при которой значения стека адресов возврата начнут перекрывать значения стека данных

- Память команд:
    - Хранит инструкции для выполнения, векторы прерываний, тела обработчиков, процедуры
    - Размер машинного слова - **32 бита**
    - Поддерживыемые типы адресации:
        - **Абсолютная**
    - Не доступна программисту
- Для обоих типов памяти характерно **линейное адресное пространство**
- Данные в памяти хранятся в формате `Big-endian`

```text
       Instruction memory
+------------------------------+
| 00  : jmp n                  |
|    ...                       |
| 10  : interruption vector 1  |
| 11  : interruption vector 2  |
|    ...                       |
| n   : program start          |
|    ...                       |
| i   : interruption handler 0 |
| i+1 : interruption handler 1 |
|    ...                       |
| f   : function 1 body        |
|    ...                       |
| g   : function 2 body        |
|    ...                       |
+------------------------------+

          Data memory
+------------------------------+
| 00  : constant 1             |
| 01  : constant 2             |
|    ...                       |
| s+0 : string literal 1 len   |
| s+1 : string literal 1 [0]   |
|    ...                       |
| v+0 : variable 1             |
| v+1 : variable 2             |
| v+2 : variable 3             |
|    ...                       |
| b   : buffer1[0]             |
| b+1 : buffer1[1]             |
|    ...                       |
| d   : data stack             |
| r   : return stack           |
|    ...                       |
+------------------------------+
```
### Регистры

Общее количество регистров - **16**. Регистры являются **32-битными**. Программист не может явно взаимодействовать ни с одним из регистров

Специальные регистры:
- `PC` (`Program Counter`): хранит адрес ячейки памяти команд, содержащей следующую исполняемую команду программы. Автоматически инкрементируется на каждом такте. Может быть изменён инструкциями перехода
- `AR` (`Address Register`): хранит адрес ячейки памяти данных
- `DR` (`Data Register`): хранит данные для операций загрузки/выгрузки данных
- `SP` (`Data Stack Pointer`): указывает на вершину стека данных
- `RP` (`Return Stack Pointer`): указывает на вершину стека адресов возврата
- `IR` (`Instruction Register`): хранит исполняемую команду
- `SPC` (`Shadow Program Counter`): используется для сохранения `PC` в случае обработки прерывания

Регистры общего назначения:
- `EAX`, `EBX`, `ECX`, `EDX`, `EFX`, `r6`, `r7`, `r8`, `r9`, `r10`: универсальные регистры

## Система команд

### Особенности процессора

- Имеется возможность разрешать и запрещать прерывания
- По умолчанию прерывания запрещены

### Виды адресации

- Регистровая (`register-to-register`): работа напрямую с регистрами

    Пример:

    ```asm
    mov EAX, EBX    ; скопировать значение из регистра EBX в регистр EAX
    ```

- Непосредственная (`immediate`): работа с непосредственно-загружаемым 32-битным значением

    Пример:

    ```asm
    mov ECX, 42     ; поместить в регистр ECX значение 42
    ```

- Косвенная (`indirect`): работа со значением, взятым из памяти данных по адресу из регистра

    Пример:

    ```asm
    mov EAX, [EDX]  ; поместить в регистр EAX значение, которое находится в памяти данных по адресу, зафиксированному в регистре EDX
    ```

- Индексная (`indirect+immediate_offset`): работа со значением, взятым из памяти данных по адресу, который является суммой непосредственного загружаемого значения и значения (адреса) из регистра

    Пример:

    ```asm
    mov EAX, [EFX + 4] ; поместить в регистр EAX значение, которое находится в памяти данных по адресу, значение которого равно сумме зафиксированного в регистре EFX + 4
    ```

### Набор инструкций

Подробное описание набора инструкций и кодов операций находится в [этом файле](./docs/isa.md) документации

### Способ кодирования инструкций

Инструкций - 31, регистров - больше 8, меньше 16. Следовательно, опкод можно закодировать минимально в 5 битах, регистр - в 4 битах

> Под поле `опкод` заложено 6 бит ради возможности расширения набора инструкций

Описание:
- `opcode` - код операции (опкод)
- `addr_t` - типы адресации для каждого из операндов (2 бита на каждый из 3 операндов = 6 бит); кодируются следующим образом:
    - `Регистровая`: `00`
    - `Непосредственная`: `01`
    - `Косвенная`: `10`
    - `Индексная`: `11`
- `rd` - регистр назначения
- `rs1` - регистр-источник #1
- `rs2` - регистр-источник #2

Для операций с типом адресации `Непосредственная` и `Индексная` непосредственное (`immediate`) значение следует вторым машинным словом

Для операций ввода-вывода номер порта кодируется 10-битным значением (таким образом, доступно 1024 портов ввода-вывода)

```
┌───────────┬──────────┬───────────┬──────────┬───────────┬──────────┐
│  31..24   │  23..20  │  19..16   │  15..12  │   11..6   │   5..0   │              
├───────────┼──────────┼───────────┼──────────┼───────────┼──────────┤
│    0x0    │    rs2   │    rs1    │    rd    │   addr_t  │  opcode  │         
└───────────┴──────────┴───────────┴──────────┴───────────┴──────────┘
```

## Модель процессора

### DataPath

![DataPath](img/DataPath.png)

### ControlUnit

![ControlUnit](img/ControlUnit.png)

## Тестирование
